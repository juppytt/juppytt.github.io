[{"content":"Hello, my name is Juhee Kim, and I am a PhD student at CompSec Lab, Department of Electrical and Computer Engineering, Seoul National University. I am advised by Byoungyoung Lee.\nMy research interests span a broad spectrum of software security issues and finding practical solutions. My research especially focused on Linux kernel security and fuzz testing. Lately, I\u0026rsquo;m interested in understanding and mitigating security risks associated with Large Language Models (LLMs).\nPublications Adil Ahmad, Juhee Kim, Jaebaek Seo, Insik Shin, Pedro Fonseca, and Byoungyoung Lee CHANCEL: Efficient Multi-client Isolation Under Adversarial Programs Network and Distributed System Security Symposium (NDSS) 2021 Education Ph.D. in Department of Electrical and Computer Engineering, Seoul National University 2020.03 - Present B.S. in Department of Electrical and Computer Engineering, Seoul National University 2015.03 - 2020.02 Things I love Workouts (Swimming, Yoga) Reading books, going to library Writing journal, research paper Listening to music (I\u0026rsquo;m recently deeply listening to Japanese bands) ","href":"/","title":"Home"},{"content":"","href":"/archive/","title":"Archive"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/kernel/","title":"kernel"},{"content":"","href":"/tags/llvm/","title":"LLVM"},{"content":"","href":"/posts/","title":"Posts"},{"content":"","href":"/tags/qemu/","title":"QEMU"},{"content":"","href":"/categories/research/","title":"research"},{"content":"Intro In the first year of my Ph.D, I ambitiously began a research on protecting the Linux kernel against data-only attacks. My research especially focused on protecting security-critical objects and pointers leveraging the ARM\u0026rsquo;s upcoming hardware security features (PAC and MTE).\nBuilding such a kernel hardening system required me to tackle several key issues:\nCross-compiling the kernel (X86 -\u0026gt; ARM64) Cross-module kernel analysis Linux kernel instrumentation Connecting the cross-module analysis with kernel build system. Setting up ARM64 environments for both emulation and a real device (Raspberry Pi 4B). As someone who was not well familar with kernel and compiler, each of these issues presented quite a challenge. So I thought it would be nice to write about each of the issues to help others facing similar issues.\n0. Environment My environment was as follows:\nHost Environment: Linux 5.15 Ubuntu 20.04.3 Clang/LLVM: 11.0.0 and 14.0.0 GNU Toolchain: aarch64-none-linux-gnu Qemu 5.1.0 Raspberry Pi 4B (4GB) 1. Building Kernel As the target system is AArch64 architecture and the host system is x86_64, the kernel needs to be cross-compiled from x86_64 to AArch64. At first, I expected Clang/LLVM would be able to do this job with -march option, as it is natively a cross-compiler. However, there was some problems related to the known cross compilation issues of Clang/LLVM. As described in ClangBuiltLinux and a blog, using ARM\u0026rsquo;s GNU toolchain (aarch64-none-linux-gnu) solves the problem.\nThe final script I used to cross-compile the kernel:\n#!/bin/bash -ve PROJ_DIR=${PWD}/.. LLVM_BUILD=${PROJ_DIR}/build/bin BINUTIL=~/util/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin export PATH=${BINUTIL}:$PATH:${LLVM_BUILD} export LLVM_COMPILER=clang export KERNEL=kernel8 export KCFLAGS=\u0026#34;-march=armv8.5-a \u0026#34; pushd ../linux-5.5 BINUTILS_TARGET_PREFIX=aarch64-none-linux-gnu make \\ ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- \\ HOSTCC=clang CC=clang -j12 popd 2. Cross-module kernel analysis To identify every instructions accessing the protection target, a cross-module data-flow analysis is performed. Here, module indicates a single C file. One approach is to use wllvm to generate a single LLVM bitcode file of the entire kernel (i.e., vmlinux.bc). Here, some kernel modules containing duplicate symbol names may occur linking errors. Such files can be manually excluded from vmlinux.bc as explained in this blog, while such modules will be excluded from the analysis.\nOnce vmlinux.bc is generated, a custom LLVM analysis pass can be applied to it, enabling the cross-module analysis. The analysis pass is implemented as a LLVM pass plugin, which is loaded by opt command. Given a list of protection target (e.g., struct types, named global variables), the analysis pass identifies the memory access instructions (i.e., load/store, copy, alloc/free) that access the protection target.\n3. Linux Kernel Instrumentation The instrumentation is applied during kernel build on the instructions identified from the analysis. The LLVM tutorial on writing a LLVM pass introduces writing a LLVM pass as a plugin tool for opt command. However, the kernel build system uses CC (clang) and LD (lld) to build the kernel, instead of opt.\nOne approach is -Xclang option to pass the instrumentation pass as a Clang pass plugin. However, for some technical reasons that I cannot recall precisely, I did not choose this approach. I may have been due to uncertainty regarding whether every module would be built with the instrumentation by -Xclang.\nAnother approach that I took is to implement the instrumentation pass as a sanitizer, which is well-supported by both Linux and clang with -fsanitize=\u0026lt;sanitizer-name\u0026gt; option. Sanitizers are implemented as LLVM passes and are automatically loaded by clang. Existing sanitizers can be found in llvm-project/llvm/lib/Transforms/Instrumentation.\nTo add a new sanitizer, several modifications were made to Clang/LLVM and this change can be found in my github repo.\nThe final script to build the kernel with the instrumentation:\n#!/bin/bash -ve PROJ_DIR=${PWD}/.. LLVM_BUILD=${PROJ_DIR}/build/bin BINUTIL=~/util/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin export PATH=${LLVM_BUILD}:${BINUTIL}:$PATH export LLVM_COMPILER=clang export KERNEL=kernel8 export KCFLAGS=\u0026#34;-march=armv8.5-a -fsanitize=kdfi_instrument \u0026#34; pushd ../linux-5.5-kdfi BINUTILS_TARGET_PREFIX=aarch64-none-linux-gnu make \\ ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- \\ HOSTCC=clang CC=clang -j12 popd 4. Connecting Analysis and Instrumentation Now the kernel can be analyzed and instrumented, but there is one more issue to solve: how do we connect the analysis and the instrumentation? A single LLVM pass for both analysis and instrumentation would be ideal. However, the kernel, as most C/C++ projects do, builds each module separately and links them together, which makes it difficult to perform cross-module analysis during kernel build.\nTo address this this, I came up with a two-pass approach: One pass is for cross-module analysis that extracts the list of instructions from a pre-compiled whole-kernel bitcode (vmlinux.bc). Another is for instrumentation that is applied to each module to perform instrumentation for the previous identified instructions.\nThis requires a way to share the list of instructions between the two LLVM passes. Here, I simply used a simple text file containing raw dump of instructions in LLVM IR format. Each instruction is accompanied by minimal metadata such as function name and instruction in order to accurately specify the intended instruction. While ths method works, I believe there are more elegant ways to share the instructions between two passes.\nAdditionally, to avoid generating an excessively large file by dumping every instruction that need to be instrumented, a simple filter in the analysis pass excludes dumping instructions if they can be identified within each module. Consequently, the instrumentation pass also performs a simple intra-module analysis to identify the instructions filtered out from the list.\n5. Arm64 Environment Setup I used two types of testing environments: QEMU and Raspberry Pi 4B (4GB). QEMU is used for debugging and security evaluation, while Raspberry Pi is used for performance evaluation.\nFor the QEMU environment, I used buildroot (v2022.02.03) to build a root file system. The entire command to run QEMU is as follows:\nLINUX=$1 sudo ~/util/qemu-5.1.0/aarch64-softmmu/qemu-system-aarch64 \\ -machine virt,mte=on \\ -cpu max \\ -nographic -smp 1 \\ -hda /home/juhee/project/ppac/buildroot-2022.02.3/output/images/rootfs.ext4 \\ -kernel $LINUX/arch/arm64/boot/Image \\ -append \u0026#34;console=ttyAMA0 root=/dev/vda oops=panic panic_on_warn=1 panic=-1 ftrace_dump_on_oops=orig_cpu debug earlyprintk=serial slub_debug=UZ nokaslr \u0026#34; \\ -m 2G \\ -net user,hostfwd=tcp::10023-:22 \\ -net nic -s -S The emulated kernel can then be debugged with aarch64-none-linux-gnu-gdb.\nTo build the kernel for Raspberry Pi, I used the official Raspberry Pi firmware for the boot files and modules. The following script builds and prepare the boot files and modules for the instrumented kernel:\n#!/bin/bash -ve PROJ_DIR=${PWD} LLVM_BUILD=${PROJ_DIR}/build/bin BINUTIL=~/util/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin export PATH=${LLVM_BUILD}:${BINUTIL}:$PATH export LLVM_COMPILER=clang export KERNEL=kernel8 export KCFLAGS=\u0026#34;-fsanitize=kdfi_instrument \u0026#34; pushd linux-rpi-6.0-$1 BINUTILS_TARGET_PREFIX=aarch64-none-linux-gnu make \\ ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- \\ CFLAGS=\u0026#34;-march=armv8-a+crc -mtune=cortex-a72\u0026#34; \\ CXXFLAGS=\u0026#34;-march=armv8-a+crc -mtune=cortex-a72\u0026#34; \\ HOSTCC=clang CC=clang -j10 \\ bindeb-pkg Image modules dtbs BINUTILS_TARGET_PREFIX=aarch64-none-linux-gnu make \\ ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- \\ HOSTCC=clang CC=clang -j10 \\ CFLAGS=\u0026#34;-march=armv8-a+crc -mtune=cortex-a72\u0026#34; \\ CXXFLAGS=\u0026#34;-march=armv8-a+crc -mtune=cortex-a72\u0026#34; \\ INSTALL_MOD_PATH=../modules-$2 \\ modules_install cp arch/arm64/boot/Image ../boot-$2/kernel8.img cp arch/arm64/boot/dts/overlays/*.dtbo ../boot-$2/overlays cp arch/arm64/boot/dts/overlays/README ../boot-$2/overlays cp arch/arm64/boot/dts/broadcom/*.dtb ../boot-$2/ popd tar -cvf modules-$2.tar.gz modules-$2/ tar -cvf boot-$2.tar.gz boot-$2/ *.deb The boot files and modules can be sent to the Raspberry Pi with network, and then can be installed with the following script:\n#!/bin/bash -ve rm *.deb tar -xvf boot-$1.tar.gz sudo rm -r /boot/* sudo dpkg -i linux-headers-*.deb linux-image-*.deb linux-libc-*.deb sudo cp -r boot-$1/* /boot/ sudo cp *.txt /boot/ tar -xvf modules-$1.tar.gz sudo cp -r modules-$1/lib/* /lib/modules/ Conclusion This post described the issues I faced when building a security hardening system for the Linux kernel. I hope this post will be helpful for others facing similar issues.\n","href":"/posts/linux-arm64-hardening/","title":"Security-hardening ARM64 Linux kernel"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/tags/config/","title":"Configuration"},{"content":"","href":"/categories/graduate-life/","title":"Graduate Life"},{"content":"","href":"/tags/og/","title":"Opengraph"},{"content":"","href":"/categories/research/","title":"Research"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
